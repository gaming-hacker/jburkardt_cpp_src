double *a123 ( );
double a123_determinant ( );
double *a123_eigen_left ( );
double *a123_eigen_right ( );
double *a123_eigenvalues ( );
double *a123_inverse ( );
double *a123_null_left ( );
double *a123_null_right ( );
void a123_plu ( double p[], double l[], double u[] );
void a123_qr ( double q[], double r[] );
double *a123_rhs ( );
double *a123_solution ( );
void a123_svd ( double u[], double s[], double v[] );
double *aegerter ( int n );
double aegerter_condition ( int n );
double aegerter_determinant ( int n );
double *aegerter_eigenvalues ( int n );
double *aegerter_inverse ( int n );
double *anticirculant ( int m, int n, double x[] );
double anticirculant_determinant ( int n, double x[] );
double *antihadamard ( int n );
double antihadamard_determinant ( int n );
double *antisymmetric_random ( int n, int key );
double *archimedes ( );
double *archimedes_null_right ( );
double *bab ( int n, double alpha, double beta );
double bab_condition ( int n, double alpha, double beta );
double bab_determinant ( int n, double alpha, double beta );
double *bab_eigen_right ( int n, double alpha, double beta );
double *bab_eigenvalues ( int n, double alpha, double beta );
double *bab_inverse ( int n, double alpha, double beta );
double *bauer ( );
double bauer_condition ( );
double bauer_determinant ( );
double *bauer_inverse ( );
double *bernstein ( int n );
double bernstein_determinant ( int n );
double *bernstein_inverse ( int n );
double *bernstein_poly_01 ( int n, double x );
double *bernstein_vandermonde ( int n );
double *bimarkov_random ( int n, int key );
double *bis ( double alpha, double beta, int m, int n );
double bis_condition ( double alpha, double beta, int n );
double bis_determinant ( double alpha, double beta, int n );
double *bis_eigenvalues ( double alpha, double beta, int n );
double *bis_inverse ( double alpha, double beta, int n );
double *biw ( int n );
double biw_condition ( int n );
double biw_determinant ( int n );
double *biw_inverse ( int n );
double *bodewig ( );
double *bodewig ( );
double bodewig_condition ( );
double bodewig_determinant ( );
double *bodewig_eigen_right ( );
double *bodewig_eigenvalues ( );
double *bodewig_inverse ( );
void bodewig_plu ( double p[], double l[], double u[] );
double *bodewig_rhs ( );
double *bodewig_solution ( );
double *boothroyd ( int n );
double boothroyd_condition ( int n );
double boothroyd_determinant ( int n );
double *boothroyd_inverse ( int n );
double *borderband ( int n );
double borderband_determinant ( int n );
double *borderband_inverse ( int n );
void borderband_plu ( int n, double p[], double l[], double u[] );
void bvec_next_grlex ( int n, int bvec[] );
double c8_abs ( complex <double> x );
complex <double> c8_i ( );
bool c8_le_l2 ( complex <double> x, complex <double> y );
complex <double> c8_normal_01 ( int &seed );
complex <double> c8_one ( );
void c8_swap ( complex <double> *x, complex <double> *y );
complex <double> c8_uniform_01 ( int &seed );
complex <double> c8_zero ( );
complex <double> *c8mat_copy_new ( int m, int n, complex <double> a[] );
complex <double> *c8mat_identity ( int n );
double c8mat_is_eigen_right ( int n, int k, complex <double> a[], 
  complex <double> x[], complex <double> lambda[] );
complex <double> *c8mat_mm_new ( int n1, int n2, int n3, complex <double> a[], 
  complex <double> b[] );
double c8mat_norm_fro ( int m, int n, complex <double> a[] );
void c8mat_print ( int m, int n, complex <double> a[], string title );
void c8mat_print_some ( int m, int n, complex <double> a[], int ilo, int jlo, 
  int ihi, int jhi, string title );
complex <double> *c8mat_uniform_01 ( int m, int n, int &seed );
complex <double> *c8mat_zero_new ( int m, int n );
complex <double> *c8vec_copy_new ( int n, complex <double> a[] );
double c8vec_norm_l2 ( int n, complex <double> a[] );
void c8vec_print ( int n, complex <double> a[], string title );
complex <double> *c8vec_uniform_01 ( int n, int &seed );
complex <double> *c8vec_unity ( int n );
double *carry ( int n, int alpha );
double carry_determinant ( int n, int alpha );
double *carry_eigen_left ( int n, int alpha );
double *carry_eigen_right ( int n, int alpha );
double *carry_eigenvalues ( int n, int alpha );
double *carry_inverse ( int n, int alpha );
double *cauchy ( int n, double x[], double y[] );
double cauchy_determinant ( int n, double x[], double y[] );
double *cauchy_inverse ( int n, double x[], double y[] );
double *cheby_diff1 ( int n );
double cheby_diff1_determinant ( int n );
double *cheby_diff1_null_left ( int m, int n );
double *cheby_diff1_null_right ( int m, int n );
double *cheby_t ( int n );
double cheby_t_determinant ( int n );
double *cheby_t_inverse ( int n );
double *cheby_u ( int n );
double cheby_u_determinant ( int n );
double *cheby_u_inverse ( int n );
double *cheby_u_polynomial ( int n, double x );
double *cheby_van1 ( int m, double x1, double x2, int n, double x[] );
double *cheby_van2 ( int n );
double cheby_van2_determinant ( int n );
double *cheby_van2_inverse ( int n );
double *cheby_van3 ( int n );
double cheby_van3_determinant ( int n );
double *cheby_van3_inverse ( int n );
double *chow ( double alpha, double beta, int m, int n );
double chow_determinant ( double alpha, double beta, int n );
double *chow_eigen_left ( double alpha, double beta, int n );
double *chow_eigen_right ( double alpha, double beta, int n );
double *chow_eigenvalues ( double alpha, double beta, int n );
double *chow_inverse ( double alpha, double beta, int n );
double *circulant ( int m, int n, double x[] );
double circulant_determinant ( int n, double x[] );
complex <double> *circulant_eigenvalues ( int n, double x[] );
double *circulant_inverse ( int n, double x[] );
double *circulant2 ( int n );
double circulant2_determinant ( int n );
complex <double> *circulant2_eigenvalues ( int n );
double *circulant2_inverse ( int n );
double *clement1 ( int n );
double clement1_determinant ( int n );
double *clement1_eigenvalues ( int n );
double *clement1_inverse ( int n );
double *clement2 ( int n, double x[], double y[] );
double clement2_determinant ( int n, double x[], double y[] );
double *clement2_inverse ( int n, double x[], double y[] );
double *colleague ( int n, double c[] );
double *combin ( double alpha, double beta, int n );
double combin_condition ( double alpha, double beta, int n );
double combin_determinant ( double alpha, double beta, int n );
double *combin_eigen_right ( double alpha, double beta, int n );
double *combin_eigenvalues ( double alpha, double beta, int n );
double *combin_inverse ( double alpha, double beta, int n );
double *companion ( int n, double x[] );
double companion_condition ( int n, double x[] );
double companion_determinant ( int n, double x[] );
double *companion_inverse ( int n, double x[] );
double complete_symmetric_poly ( int n, int r, double x[] );
complex <double> *complex3 ( );
complex <double> *complex3_inverse ( );
double *complex_i ( );
double complex_i_determinant ( );
double *complex_i_inverse ( );
double *conex1 ( double alpha );
double conex1_condition ( double alpha );
double conex1_determinant ( double alpha );
double *conex1_inverse ( double alpha );
double *conex2 ( double alpha );
double conex2_condition ( double alpha );
double conex2_determinant ( double alpha );
double *conex2_inverse ( double alpha );
double *conex3 ( int n );
double conex3_condition ( int n );
double conex3_determinant ( int n );
double *conex3_inverse ( int n );
double *conex4 ( );
double conex4_condition ( );
double conex4_determinant ( );
double *conex4_inverse ( );
double *conference ( int n );
double conference_determinant ( int n );
double *conference_inverse ( int n );
double *creation ( int m, int n );
double creation_determinant ( int n );
double *creation_null_left ( int m, int n );
double *creation_null_right ( int m, int n );
double *cycol_random ( int m, int n, int k, int key );
double *daub2 ( int n );
double daub2_condition ( int n );
double daub2_determinant ( int n );
double *daub2_inverse ( int n );
double *daub4 ( int n );
double daub4_condition ( int n );
double daub4_determinant ( int n );
double *daub4_inverse ( int n );
double *daub6 ( int n );
double daub6_condition ( int n );
double daub6_determinant ( int n );
double *daub6_inverse ( int n );
double *daub8 ( int n );
double daub8_condition ( int n );
double daub8_determinant ( int n );
double *daub8_inverse ( int n );
double *daub10 ( int n );
double daub10_condition ( int n );
double daub10_determinant ( int n );
double *daub10_inverse ( int n );
double *daub12 ( int n );
double daub12_condition ( int n );
double daub12_determinant ( int n );
double *daub12_inverse ( int n );
double *diagonal ( int m, int n, double x[] );
double diagonal_condition ( int n, double x[] );
double diagonal_determinant ( int n, double x[] );
double *diagonal_eigen_left ( int n, double d[] );
double *diagonal_eigen_right ( int n, double d[] );
double *diagonal_eigenvalues ( int n, double x[] );
double *diagonal_inverse ( int n, double x[] );
double *dif1 ( int m, int n );
double dif1_determinant ( int n );
complex <double> *dif1_eigenvalues ( int n );
double *dif1_inverse ( int n );
double *dif1_null_left ( int m, int n );
double *dif1_null_right ( int m, int n );
double *dif1cyclic ( int n );
double dif1cyclic_determinant ( int n );
double *dif1cyclic_null_left ( int m, int n );
double *dif1cyclic_null_right ( int m, int n );
double *dif2 ( int m, int n );
double dif2_condition ( int n );
double dif2_determinant ( int n );
double *dif2_eigen_right ( int n );
double *dif2_eigenvalues ( int n );
double *dif2_inverse ( int n );
double *dif2_llt ( int n );
void dif2_plu ( int n, double p[], double l[], double u[] );
double *dif2_rhs ( int m, int k );
double *dif2_rtr ( int n );
double *dif2_solution ( int n, int k );
double *dif2cyclic ( int n );
double dif2cyclic_determinant ( int n );
double *dif2cyclic_null_left ( int m, int n );
double *dif2cyclic_null_right ( int m, int n );
double *dorr ( double alpha, int n );
double dorr_determinant ( double alpha, int n );
double *dorr_inverse ( double alpha, int n );
double *downshift ( int n );
double downshift_condition ( int n );
double downshift_determinant ( int n );
complex <double> *downshift_eigenvalues ( int n );
double *downshift_inverse ( int n );
double *eberlein ( double alpha, int n );
double eberlein_determinant ( double alpha, int n );
double *eberlein_eigenvalues ( double alpha, int n );
double *eberlein_null_left ( int m, int n );
double *eulerian ( int m, int n );
double eulerian_determinant ( int n );
double *eulerian_inverse ( int n );
double *exchange ( int m, int n );
double exchange_condition ( int n );
double exchange_determinant ( int n );
double *exchange_eigen_right ( int n );
double *exchange_eigenvalues ( int n );
double *exchange_inverse ( int n );
double *fibonacci1 ( int n, double f1, double f2 );
double fibonacci1_determinant ( int n, double f1, double f2 );
double *fibonacci1_null_left ( int m, int n, double f1, double f2 );
double *fibonacci1_null_right ( int m, int n, double f1, double f2 );
double *fibonacci2_matrix ( int n );
double fibonacci2_condition ( int n );
double fibonacci2_determinant ( int n );
double *fibonacci2_eigen_right ( int n );
double *fibonacci2_eigenvalues ( int n );
double *fibonacci2_inverse ( int n );
double *fibonacci3 ( int n );
double fibonacci3_determinant ( int n );
complex <double> *fibonacci3_eigenvalues ( int n );
double *fibonacci3_inverse ( int n );
double *fiedler ( int m, int n, double x[] );
double fiedler_determinant ( int n, double x[] );
double *fiedler_inverse ( int n, double x[] );
double *forsythe ( double alpha, double beta, int n );
double forsythe_determinant ( double alpha, double beta, int n );
complex <double> *forsythe_eigenvalues ( double alpha, double beta, int n );
double *forsythe_inverse ( double alpha, double beta, int n );
complex <double> *fourier ( int n );
complex <double> fourier_determinant ( int n );
complex <double> *fourier_eigenvalues ( int n );
complex <double> *fourier_inverse ( int n );
double *fourier_cosine ( int n );
double fourier_cosine_determinant ( int n );
double *fourier_cosine_inverse ( int n );
double *fourier_sine ( int n );
double fourier_sine_determinant ( int n );
double *fourier_sine_inverse ( int n );
double *frank ( int n );
double frank_determinant ( int n );
double *frank_eigenvalues ( int n );
double *frank_inverse ( int n );
double *frank_rhs ( int m, int k );
double *frank_solution ( int n, int k );
double *gfpp ( int n, double alpha );
double gfpp_condition ( int n, double alpha );
double gfpp_determinant ( int n, double alpha );
double *gfpp_inverse ( int n, double alpha );
void gfpp_plu ( int n, double alpha, double p[], double l[], double u[] );
double *givens ( int m, int n );
double givens_condition ( int n );
double givens_determinant ( int n );
double *givens_eigenvalues ( int n );
double *givens_inverse ( int n );
double *givens_llt ( int n );
void givens_plu ( int n, double p[], double l[], double u[] );
double *gk316 ( int n );
double gk316_determinant ( int n );
double *gk316_eigenvalues ( int n );
double *gk316_inverse ( int n );
double *gk323 ( int m, int n );
double gk323_determinant ( int n );
double *gk323_inverse ( int n );
double *gk324 ( int m, int n, double x[] );
double gk324_determinant ( int n, double x[] );
double *gk324_inverse ( int n, double x[] );
double *grcar ( int m, int n, int k );
double *hadamard ( int m, int n );
double *hamming ( int m, int n );
double *hamming_null_right ( int m, int n );
double *hankel ( int n, double x[] );
double *hankel_n ( int n );
double hankel_n_condition ( int n );
double hankel_n_determinant ( int n );
double *hankel_n_inverse ( int n );
double *hanowa ( double alpha, int n );
double hanowa_determinant ( double alpha, int n );
complex <double> *hanowa_eigenvalues ( double alpha, int n );
double *hanowa_inverse ( double alpha, int n );
double *harman ( );
double harman_condition ( );
double harman_determinant ( );
double *harman_eigenvalues ( );
double *harman_inverse ( );
double *hartley ( int n );
double hartley_condition ( int n );
double hartley_determinant ( int n );
double *hartley_inverse ( int n );
double *helmert ( int n );
double helmert_determinant ( int n );
double *helmert_inverse ( int n );
double *helmert2 ( int n, double x[] );
double *helmert2_inverse ( int n, double x[] );
double *hermite ( int n );
double hermite_determinant ( int n );
double *hermite_inverse ( int n );
double *hermite_roots ( int order );
double *herndon ( int n );
double herndon_determinant ( int n );
double *herndon_eigenvalues ( int n );
double *herndon_inverse ( int n );
complex <double> *hess4 ( );
complex <double> hess4_determinant ( );
complex <double> *hess4_eigen_right ( );
complex <double> *hess4_eigenvalues ( );
complex <double> *hess4_inverse ( );
double *hess5 ( );
double hess5_determinant ( );
complex <double> *hess5_eigen_right ( );
complex <double> *hess5_eigenvalues ( );
double *hess5_inverse ( );
double *hilbert ( int m, int n );
double hilbert_determinant ( int n );
double *hilbert_inverse ( int n );
double *hoffman ( double omega );
double *hoffman_rhs ( );
double *hoffman_optimum ( );
double *householder ( int n, double x[] );
double householder_determinant ( int n, double x[] );
double *householder_eigenvalues ( int n, double x[] );
double *householder_inverse ( int n, double x[] );
void i4_factor ( int n, int maxfactor, int &nfactor, int factor[], 
  int exponent[], int &nleft );
int i4_huge ( );
bool i4_is_even ( int i );
bool i4_is_odd ( int i );
bool i4_is_prime ( int n );
int i4_log_10 ( int i );
int i4_max ( int i1, int i2 );
int i4_min ( int i1, int i2 );
int i4_modp ( int i, int j );
int i4_power ( int i, int j );
int i4_rise ( int i, int n );
int i4_sign ( int i );
int i4_uniform_ab ( int a, int b, int &seed );
int i4_wrap ( int ival, int ilo, int ihi );
void i4mat_print ( int m, int n, int a[], string title );
void i4mat_print_some ( int m, int n, int a[], int ilo, int jlo, int ihi, 
  int jhi, string title );
int i4vec_index ( int n, int a[], int aval );
int *i4vec_indicator_new ( int n );
void i4vec_print ( int n, int a[], string title );
double *idempotent_random ( int n, int rank, int key );
double idempotent_random_determinant ( int n, int rank, int key );
double *idempotent_random_eigen_right ( int n, int rank, int key );
double *idempotent_random_eigenvalues ( int n, int rank, int key );
double *identity ( int m, int n );
double identity_condition ( int n );
double identity_determinant ( int n );
double *identity_eigen_left ( int n );
double *identity_eigen_right ( int n );
double *identity_eigenvalues ( int n );
double *identity_inverse ( int n );
double *ijfact1 ( int n );
double ijfact1_determinant ( int n );
double *ijfact2 ( int n );
double ijfact2_determinant ( int n );
double *ill3 ( );
double ill3_condition ( );
double ill3_determinant ( );
double *ill3_eigen_right ( );
double *ill3_eigenvalues ( );
double *ill3_inverse ( );
double *indicator ( int m, int n );
double *integration ( double alpha, int n );
double integration_determinant ( double alpha, int n );
double *integration_eigenvalues ( double alpha, int n );
double *integration_inverse ( double alpha, int n );
double *involutory ( int n );
double involutory_determinant ( int n );
double *involutory_eigenvalues ( int n );
double *involutory_inverse ( int n );
double *involutory_random ( int n, int rank, int key );
double *jacobi ( int m, int n );
double jacobi_determinant ( int n );
double *jacobi_eigenvalues ( int n );
double *jacobi_inverse ( int n );
void jacobi_iterate ( int n, double a[], double lambda[], double x[] );
int jacobi_symbol ( int q, int p );
double *jordan ( int m, int n, double alpha );
double jordan_condition ( int n, double alpha );
double jordan_determinant ( int n, double alpha );
double *jordan_eigenvalues ( int n, double alpha );
double *jordan_inverse ( int n, double alpha );
double *kahan ( double alpha, int m, int n );
double kahan_determinant ( double alpha, int n );
double *kahan_inverse ( double alpha, int n );
double *kershaw ( );
double kershaw_condition ( );
double kershaw_determinant ( );
double *kershaw_eigen_right ( );
double *kershaw_eigenvalues ( );
double *kershaw_inverse ( );
double *kershaw_llt ( );
double *kershawtri ( int n, double x[] );
double kershawtri_determinant ( int n, double x[] );
double *kershawtri_inverse ( int n, double x[] );
double *kms ( double alpha, int m, int n );
double kms_determinant ( double alpha, int n );
double *kms_eigen_right ( double alpha, int n );
double *kms_eigenvalues ( double alpha, int n );
double *kms_eigenvalues_theta ( double alpha, int n );
double kms_eigenvalues_theta_f ( double alpha, int n, double t );
double *kms_inverse ( double alpha, int n );
void kms_ldl ( double alpha, int n, double **l, double **d );
void kms_plu ( double alpha, int n, double p[], double l[], double u[] );
double *krylov ( int n, double b[], double x[] );
double *laguerre ( int n );
double laguerre_determinant ( int n );
double *laguerre_inverse ( int n );
double *lauchli ( double alpha, int m, int n );
double *lauchli_null_left ( double alpha, int m, int n );
double *legendre ( int n );
double legendre_determinant ( int n );
double *legendre_inverse ( int n );
int legendre_symbol ( int q, int p );
double *legendre_van ( int m, int n, double x[] );
double *legendre_zeros ( int n );
double *lehmer ( int m, int n );
double lehmer_determinant ( int n );
double *lehmer_inverse ( int n );
double *lehmer_llt ( int n );
void lehmer_plu ( int n, double p[], double l[], double u[] );
double *leslie ( double b, double di, double da );
double leslie_determinant ( double b, double di, double da );
double *lesp ( int m, int n );
double lesp_determinant ( int n );
double *lesp_inverse ( int n );
double *lietzke ( int n );
double lietzke_condition ( int n );
double lietzke_determinant ( int n );
double *lietzke_inverse ( int n );
double *line_adj ( int n );
double line_adj_determinant ( int n );
double *line_adj_eigen_right ( int n );
double *line_adj_eigenvalues ( int n );
double *line_adj_inverse ( int n );
double *line_adj_null_left ( int m, int n );
double *line_adj_null_right ( int m, int n );
double *line_loop_adj ( int n );
double line_loop_adj_determinant ( int n );
double *line_loop_adj_eigen_right ( int n );
double *line_loop_adj_eigenvalues ( int n );
double *loewner ( double w[], double x[], double y[], double z[], int n );
double *lotkin ( int m, int n );
double lotkin_determinant ( int n );
double *lotkin_inverse ( int n );
double *markov_random ( int n, int key );
double *maxij ( int m, int n );
double maxij_condition ( int n );
double maxij_determinant ( int n );
double *maxij_inverse ( int n );
void maxij_plu ( int n, double p[], double l[], double u[] );
int mertens ( int n );
void mertens_values ( int &n_data, int &n, int &c );
double *milnes ( int m, int n, double x[] );
double milnes_determinant ( int n, double x[] );
double *milnes_inverse ( int n, double x[] );
double *minij ( int m, int n );
double minij_condition ( int n );
double minij_determinant ( int n );
double *minij_eigenvalues ( int n );
double *minij_inverse ( int n );
double *minij_llt ( int n );
void minij_plu ( int n, double p[], double l[], double u[] );
int moebius ( int n );
void moebius_values ( int &n_data, int &n, int &c );
double *moler1 ( double alpha, int m, int n );
double moler1_determinant ( double alpha, int n );
double *moler1_inverse ( double alpha, int n );
double *moler1_llt ( double alpha, int );
void moler1_plu ( double alpha, int n, double p[], double l[], double u[] );
double *moler2 ( );
double moler2_determinant ( );
double *moler2_eigenvalues ( );
double *moler2_null_left ( );
double *moler2_null_right ( );
double *moler3 ( int m, int n );
double moler3_determinant ( int n );
double *moler3_inverse ( int n );
double *moler3_llt ( int n );
void moler3_plu ( int n, double p[], double l[], double u[] );
double *moler4 ( );
double moler4_condition ( );
double moler4_determinant ( );
double *moler4_eigenvalues ( );
double *moler4_inverse ( );
double *neumann ( int nrow, int ncol );
double neumann_determinant ( int n );
double *neumann_null_right ( int nrow, int ncol );
double *one ( int m, int n );
double one_determinant ( int n );
double *one_eigen_right ( int n );
double *one_eigenvalues ( int n );
double *one_null_left ( int m, int n );
double *one_null_right ( int m, int n );
double *ortega ( int n, double u[], double v[], double d[] );
double ortega_determinant ( int n, double u[], double v[], double d[] );
double *ortega_eigen_right ( int n, double u[], double v[], double d[] );
double *ortega_eigenvalues ( int n, double u[], double v[], double d[] );
double *ortega_inverse ( int n, double u[], double v[], double d[] );
double *orthogonal_random ( int n, int key );
double orthogonal_random_determinant ( int n, int key );
double *orthogonal_random_inverse ( int n, int key );
double *orthogonal_symmetric ( int n );
double orthogonal_symmetric_condition ( int n );
double orthogonal_symmetric_determinant ( int n );
double *orthogonal_symmetric_eigenvalues ( int n );
double *orthogonal_symmetric_inverse ( int n );
double *oto ( int m, int n );
double oto_condition ( int n );
double oto_determinant ( int n );
double *oto_eigen_right ( int n );
double *oto_eigenvalues ( int n );
double *oto_inverse ( int n );
double *oto_llt ( int n );
void oto_plu ( int n, double p[], double l[], double u[] );
double *parlett ( );
double *parlett_eigenvalues ( );
double *parter ( int m, int n );
double parter_determinant ( int n );
double *parter_inverse ( int n );
double *pascal1 ( int n );
double pascal1_condition ( int n );
double pascal1_determinant ( int n );
double *pascal1_eigenvalues ( int n );
double *pascal1_inverse ( int n );
double *pascal2 ( int n );
double pascal2_determinant ( int n );
double *pascal2_inverse ( int n );
double *pascal2_llt ( int n );
void pascal2_plu ( int n, double p[], double l[], double u[] );
double *pascal3 ( int n, double alpha );
double pascal3_condition ( int n, double alpha );
double pascal3_determinant ( int n, double alpha );
double *pascal3_inverse ( int n, double alpha );
double *spd_random ( int n, int key );
double spd_random_determinant ( int n, int key );
double *spd_random_eigen_right ( int n, int key );
double *spd_random_eigenvalues ( int n, int key );
double *spd_random_inverse ( int n, int key );
double *pei ( double alpha, int n );
double pei_condition ( double alpha, int n );
double pei_determinant ( double alpha, int n );
double *pei_eigen_right ( double alpha, int n );
double *pei_eigenvalues ( double alpha, int n );
double *pei_inverse ( double alpha, int n );
bool perm_check ( int n, int p[] );
void perm_inverse ( int n, int p[] );
int *perm_mat_to_vec ( int n, double a[] );
int perm_sign ( int n, int p[] );
double *perm_vec_to_mat ( int n, int p[] );
double permutation_determinant ( int n, double a[] );
double *permutation_random ( int n, int key );
double permutation_random_determinant ( int n, int key );
double *permutation_random_inverse ( int n, int key );
complex <double> *pick ( int n, complex <double> w[], complex <double> z[] );
double *plu ( int n, int pivot[] );
double plu_determinant ( int n, int pivot[] );
double *plu_inverse ( int n, int pivot[] );
void plu_plu ( int n, int pivot[], double p[], double l[], double u[] );
double *poisson ( int nrow, int ncol );
double poisson_determinant ( int nrow, int ncol );
double *poisson_eigenvalues ( int nrow, int ncol );
double *poisson_rhs ( int nrow, int ncol );
double *poisson_solution ( int nrow, int ncol );
int prime ( int n );
double *prolate ( double alpha, int n );
double *quaternion_i ( );
double *quaternion_j ( );
double *quaternion_k ( );
double r8_choose ( int n, int k );
double r8_cube_root ( double x );
double r8_epsilon ( );
double r8_factorial ( int n );
double r8_huge ( );
double r8_max ( double x, double y );
double r8_mop ( int i );
int r8_nint ( double x );
double r8_normal_01 ( int &seed );
double r8_sign ( double x );
double r8_uniform_ab ( double b, double c, int &seed );
double r8_uniform_01 ( int &seed );
void r8col_swap ( int m, int n, double a[], int j1, int j2 );
double *r8col_to_r8vec ( int m, int n, double a[] );
void r8mat_copy ( int m, int n, double a1[], double a2[] );
double *r8mat_copy_new ( int m, int n, double a1[] );
double r8mat_determinant ( int n, double a[] );
double *r8mat_diag_get_vector ( int n, double a[] );
double r8mat_gedet ( double a[], int n, int pivot[] );
int r8mat_gefa ( double a[], int n, int pivot[] );
void r8mat_geinverse ( double a[], int n, int pivot[] );
void r8mat_house_axh ( int n, double a[], double v[] );
double *r8mat_house_axh_new ( int n, double a[], double v[] );
double *r8mat_house_form ( int n, double v[] );
double *r8mat_identity ( int n );
double *r8mat_inverse ( int n, double a[] );
int r8mat_is_adjacency ( int m, int n, double a[] );
int r8mat_is_anticirculant ( int m, int n, double a[] );
double r8mat_is_antipersymmetric ( int m, int n, double a[] );
double r8mat_is_antisymmetric ( int m, int n, double a[] );
int r8mat_is_diagonally_dominant ( int n, double a[] );
int r8mat_is_diagonally_dominant_column ( int m, int n, double a[] );
int r8mat_is_diagonally_dominant_row ( int m, int n, double a[] );
double r8mat_is_eigen_left ( int n, int k, double a[], double x[],
  double lambda[] );
double r8mat_is_eigen_right ( int n, int k, double a[], double x[],
  double lambda[] );
double r8mat_is_identity ( int n, double a[] );
double r8mat_is_integer ( int m, int n, double a[] );
double r8mat_is_inverse ( int n, double a[], double b[] );
double r8mat_is_inverse_left ( int m, int n, double a[], double b[] );
double r8mat_is_inverse_right ( int m, int n, double a[], double b[] );
double r8mat_is_llt ( int m, int n, double a[], double l[] );
double r8mat_is_null_left ( int m, int n, double a[], double x[] );
double r8mat_is_null_right ( int m, int n, double a[], double x[] );
double r8mat_is_orthogonal ( int m, int n, double a[] );
double r8mat_is_orthogonal_column ( int m, int n, double a[] );
double r8mat_is_orthogonal_row ( int m, int n, double a[] );
int r8mat_is_permutation ( int m, int n, double a[] );
double r8mat_is_plu ( int m, int n, double a[], double p[], double l[], 
  double u[] );
double r8mat_is_solution ( int m, int n, int k, double a[], double x[], 
  double b[] );
bool r8mat_is_square ( int m, int n, double a[] );
double r8mat_is_symmetric ( int m, int n, double a[] );
double r8mat_is_transition ( int m, int n, double a[] );
void r8mat_is_triangular ( int m, int n, double a[], int &ival, int &jval );
int r8mat_is_zero_one ( int m, int n, double a[] );
double *r8mat_mm_new ( int n1, int n2, int n3, double a[], double b[] );
double *r8mat_mmt_new ( int n1, int n2, int n3, double a[], double b[] );
double *r8mat_mtm_new ( int n1, int n2, int n3, double a[], double b[] );
double r8mat_norm_eis ( int m, int n, double a[] );
double r8mat_norm_fro ( int m, int n, double a[] );
double r8mat_norm_l1 ( int m, int n, double a[] );
double r8mat_norm_l2 ( int m, int n, double a[] );
double r8mat_norm_li ( int m, int n, double a[] );
void r8mat_plot ( int m, int n, double a[], string title );
char r8mat_plot_symbol ( double r );
double *r8mat_poly_char ( int n, double a[] );
void r8mat_print ( int m, int n, double a[], string title );
void r8mat_print_some ( int m, int n, double a[], int ilo, int jlo, int ihi, 
  int jhi, string title );
void r8mat_symm_jacobi ( int n, double a[] );
complex <double> *r8mat_to_c8mat ( int m, int n, double r8mat[] );
double r8mat_trace ( int n, double a[] );
double *r8mat_transpose_new ( int m, int n, double a[] );
void r8mat_transpose_in_place ( int n, double a[] );
double *r8mat_uniform_01_new ( int m, int n, int &seed );
double *r8mat_uniform_ab_new ( int m, int n, double b, double c, int &seed );
double *r8mat_zero_new ( int m, int n );
int r8poly_degree ( int na, double a[] );
void r8poly_print ( int n, double a[], string title );
void r8row_swap ( int m, int n, double a[], int irow1, int irow2 );
double *r8row_to_r8vec ( int m, int n, double a[] );
double r8vec_amax ( int n, double r8vec[] );
double r8vec_amin ( int n, double r8vec[] );
double r8vec_asum ( int n, double a[] );
void r8vec_copy ( int n, double a1[], double a2[] );
double *r8vec_copy_new ( int n, double a1[] );
double r8vec_dot_product ( int n, double a1[], double a2[] );
double *r8vec_house_column ( int n, double a[], int k );
double *r8vec_indicator_new ( int n );
double *r8vec_linspace_new ( int n, double a_first, double a_last );
double r8vec_max ( int n, double r8vec[] );
double r8vec_norm_l2 ( int n, double a[] );
void r8vec_print ( int n, double a[], string title );
double r8vec_product ( int n, double a[] );
void r8vec_sort_bubble_a ( int n, double a[] );
double r8vec_sum ( int n, double a[] );
double *r8vec_uniform_01_new ( int n, int &seed );
double *r8vec_uniform_ab_new ( int n, double b, double c, int &seed );
void r8vec_zero ( int n, double a[] );
double *r8vec_zero_new ( int n );
void r8vec2_print ( int n, double a1[], double a2[], string title );
double rayleigh ( int n, double a[], double x[] );
double rayleigh2 ( int n, double a[], double x[], double y[] );
double rectangle_adj_determinant ( int row_num, int col_num );
double *redheffer ( int n );
double redheffer_determinant ( int n );
double *ref_random ( int m, int n, double prob, int key );
double ref_random_determinant ( int n, double prob, int key );
double *riemann ( int m, int n );
double *ring_adj ( int n );
double ring_adj_determinant ( int n );
double *ring_adj_null_left ( int m, int n );
double *ring_adj_null_right ( int m, int n );
double *ris ( int n );
double ris_determinant ( int n );
double *ris_inverse ( int n );
double *rodman ( int m, int n, double alpha );
double rodman_condition ( int n, double alpha );
double rodman_determinant ( int n, double alpha );
double *rodman_eigen_right ( int n, double alpha );
double *rodman_eigenvalues ( int n, double alpha );
double *rodman_inverse ( int n, double alpha );
double *rosser1 ( );
double rosser1_determinant ( );
double *rosser1_eigen_left ( );
double *rosser1_eigen_right ( );
double *rosser1_eigenvalues ( );
double *rosser1_null_left ( );
double *rosser1_null_right ( );
double *routh ( int n, double x[] );
double routh_determinant ( int n, double x[] );
double *rowcolsum_matrix ( int row_num, int col_num, int &m, int &n );
double *rutis1 ( );
double rutis1_condition ( );
double rutis1_determinant ( );
double *rutis1_eigen_right ( );
double *rutis1_eigenvalues ( );
double *rutis1_inverse ( );
double *rutis2 ( );
double rutis2_condition ( );
double rutis2_determinant ( );
double *rutis2_eigen_right ( );
double *rutis2_eigenvalues ( );
double *rutis2_inverse ( );
double *rutis3 ( );
double rutis3_condition ( );
double rutis3_determinant ( );
complex <double> *rutis3_eigen_left ( );
complex <double> *rutis3_eigen_right ( );
complex <double> *rutis3_eigenvalues ( );
double *rutis3_inverse ( );
double *rutis4 ( int n );
double rutis4_determinant ( int n );
double *rutis4_eigenvalues ( int n );
double *rutis4_inverse ( int n );
double *rutis5 ( );
double rutis5_condition ( );
double rutis5_determinant ( );
double *rutis5_eigen_right ( );
double *rutis5_eigenvalues ( );
double *rutis5_inverse ( );
double *schur_block ( int n, double x[], double y[] );
double schur_block_determinant ( int n, double x[], double y[] );
complex <double> *schur_block_eigenvalues ( int n, double x[], double y[] );
double *schur_block_inverse ( int n, double x[], double y[] );
double *skew_circulant ( int m, int n, double x[] );
double skew_circulant_determinant ( int n, double x[] );
complex <double> *skew_circulant_eigenvalues ( int n, double x[] );
complex <double> *smoke1 ( int n );
double smoke1_determinant ( int n );
complex <double> *smoke1_eigenvalues ( int n );
complex <double> *smoke2 ( int n );
double smoke2_determinant ( int n );
complex <double> *smoke2_eigenvalues ( int n );
double *snakes ( );
void sort_heap_external ( int n, int &indx, int &i, int &j, int isgn );
double *spline ( int n, double x[] );
double spline_determinant ( int n, double x[] );
double *spline_inverse ( int n, double x[] );
double *stirling ( int m, int n );
double stirling_determinant ( int n );
double *stirling_inverse ( int n );
double *stripe ( int n );
void subset_random ( int n, int &seed, int a[] );
double *sudoku_adj ( );
double *summation ( int m, int n );
double summation_condition ( int n );
double summation_determinant ( int n );
double *summation_eigenvalues ( int n );
double *summation_inverse ( int n );
double *sweet1 ( );
double sweet1_condition ( );
double sweet1_determinant ( );
double *sweet1_inverse ( );
double *sweet2 ( );
double sweet2_condition ( );
double sweet2_determinant ( );
double *sweet2_inverse ( );
double *sweet3 ( );
double sweet3_condition ( );
double sweet3_determinant ( );
double *sweet3_inverse ( );
double *sweet4 ( );
double sweet4_condition ( );
double sweet4_determinant ( );
double *sweet4_inverse ( );
double *sylvester ( int n, int nx, double x[], int ny, double y[] );
double *sylvester_kac ( int n );
double sylvester_kac_determinant ( int n );
double *sylvester_kac_eigen_right ( int n );
double *sylvester_kac_eigenvalues ( int n );
double *sylvester_kac_inverse ( int n );
double *symmetric_random ( int n, double d[], int key );
double symmetric_random_determinant ( int n, double d[], int key );
double *symmetric_random_eigen_left ( int n, double d[], int key );
double *symmetric_random_eigen_right ( int n, double d[], int key );
double *symmetric_random_eigenvalues ( int n, double d[], int key );
double *symmetric_random_inverse ( int n, double d[], int key );
void timestamp ( );
double *toeplitz ( int n, double x[] );
double *toeplitz_5diag ( int n, double d1, double d2, double d3, double d4, 
  double d5 );
double *toeplitz_5s ( int row_num, int col_num, double alpha, double beta, 
  double gamma, int n );
double toeplitz_5s_determinant ( int row_num, int col_num, double alpha, 
  double beta, double gamma );
double *toeplitz_5s_eigenvalues ( int row_num, int col_num, double alpha, 
  double beta, double gamma );
double *toeplitz_spd ( int m, int n, double x[], double y[] );
double *tournament_random ( int n, int key );
double tournament_random_determinant ( int n, int key );
double *transition_random ( int n, int key );
double *trench ( double alpha, int m, int n );
double *tri_l1_inverse ( int n, double a[] );
double *tri_u_inverse ( int n, double a[] );
double *tri_upper ( double alpha, int n );
double tri_upper_condition ( double alpha, int n );
double tri_upper_determinant ( double alpha, int n );
double *tri_upper_eigenvalues ( int n );
double *tri_upper_inverse ( double alpha, int n );
void tribonacci_roots ( double &alpha, complex <double> &beta, 
  complex <double> &gamma );
double tribonacci2_determinant ( int n );
complex <double> *tribonacci2_eigen_right ( int n );
complex <double> *tribonacci2_eigenvalues ( int n );
double *tribonacci2_matrix ( int n );
double tridiagonal_determinant ( int n, double a[] );
double *tris ( int m, int n, double x, double y, double z );
double tris_determinant ( int n, double x, double y, double z );
complex <double> *tris_eigenvalues ( int n, double x, double y, double z );
double *tris_inverse ( int n, double alpha, double beta, double gamma );
double *triv ( int n, double x[], double y[], double z[]  );
double triv_determinant ( int n, double x[], double y[], double z[]  );
double *triv_inverse ( int n, double x[], double y[], double z[] );
double *triw ( double alpha, int k, int n );
double triw_determinant ( double alpha, int k, int n );
double *triw_eigenvalues ( int n );
double *triw_inverse ( double alpha, int k, int n );
double *upshift ( int n );
double upshift_condition ( int n );
double upshift_determinant ( int n );
complex <double> *upshift_eigenvalues ( int n );
double *upshift_inverse ( int n );
double *vand1 ( int n, double x[] );
double vand1_determinant ( int n, double x[] );
double *vand1_inverse ( int n, double x[] );
void vand1_inverse_ul ( int n, double x[], double u[], double l[] );
double *vand2 ( int n, double x[] );
double vand2_determinant ( int n, double x[] );
double *vand2_inverse ( int n, double x[] );
void vand2_inverse_ul ( int n, double x[], double u[], double l[] );
void vand2_lu ( int n, double x[], double l[], double u[] );
void vand2_plu ( int n, double x[], double p[], double l[], double u[] );
double *wathen ( int nx, int ny, int n );
int wathen_order ( int nx, int ny );
double *wilk03 ( );
double wilk03_condition ( );
double wilk03_determinant ( );
double *wilk03_eigenvalues ( );
double *wilk03_inverse ( );
double *wilk03_rhs ( );
double *wilk03_solution ( );
double *wilk04 ( );
double wilk04_condition ( );
double wilk04_determinant ( );
double *wilk04_eigenvalues ( );
double *wilk04_inverse ( );
double *wilk04_rhs ( );
double *wilk04_solution ( );
double *wilk05 ( );
double wilk05_condition ( );
double wilk05_determinant ( );
double *wilk05_inverse ( );
double *wilk12 ( );
double wilk12_condition ( );
double wilk12_determinant ( );
double *wilk12_eigen_right ( );
double *wilk12_eigenvalues ( );
double *wilk20 ( double alpha );
double *wilk21 ( int n );
double wilk21_determinant ( int n );
double *wilk21_inverse ( int n );
double *wilson ( );
double wilson_condition ( );
double wilson_determinant ( );
double *wilson_eigen_right ( );
double *wilson_eigenvalues ( );
double *wilson_inverse ( );
double *wilson_llt ( );
void wilson_plu ( double p[], double l[], double u[] );
double *wilson_rhs ( );
double *wilson_solution ( );
double *zero ( int m, int n );
double zero_determinant ( int n );
double *zero_eigen_right ( int n );
double *zero_eigenvalues ( int n );
double *zero_null_right ( int m, int n );
double *zero_null_left ( int m, int n );
double *zielke ( int n, double x, double y, double z );
